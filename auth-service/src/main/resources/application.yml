server:
  port: 0 # Configuración del servidor web embebido (ej. Tomcat o Jetty)
    # Un puerto de '0' significa que Spring Boot asignará un puerto aleatorio disponible.
    # Esto es una práctica común y muy recomendada para microservicios en un entorno de descubrimiento (como Eureka).
  # De esta manera, no tienes que preocuparte por conflictos de puertos si ejecutas múltiples instancias
  # del mismo microservicio o si tienes muchos microservicios en un mismo host.
logging:
  level:
    org.springframework.cloud.loadbalancer: DEBUG
    feign: DEBUG
    org.apache.kafka: DEBUG # Añadido para depurar la comunicación con Kafka
    org.springframework.kafka: DEBUG # Añadido para depurar la comunicación con Kafka
    org.springframework.security: DEBUG
spring:
  profiles:
    active: dev # Define el perfil de Spring activo. Esto permite tener configuraciones diferentes
      # para distintos entornos (ej. 'dev' para desarrollo, 'prod' para producción).
    # Cuando el microservicio se inicie, buscará 'application-dev.yml' si existe,
    # y anulará las propiedades definidas aquí si hay duplicados.

  datasource: # Configuración para la conexión a la base de datos.
    url: jdbc:postgresql://localhost:5433/auth_db_name # Asegúrate de que el nombre de la DB es auth_db_name y el puerto es el correcto.
    username: auth_user # Usuario de la base de datos, debe coincidir con tu docker-compose.yml
    password: auth_password # Contraseña de la base de datos, debe coincidir con tu docker-compose.yml
    driver-class-name: org.postgresql.Driver # Clase del driver JDBC para PostgreSQL

  jpa: # Configuración de Spring Data JPA (que usa Hibernate por defecto).
    hibernate:
      ddl-auto: update # Estrategia de DDL (Data Definition Language).
        # 'update' intentará actualizar el esquema de la base de datos
        # (crear tablas, añadir columnas) para que coincida con tus entidades JPA.
      # ¡CUIDADO! En producción, normalmente usarías 'none' y gestionarías los esquemas
      # con herramientas de migración (ej. Flyway, Liquibase).
    show-sql: true     # Si es 'true', Hibernate mostrará todas las consultas SQL que ejecuta en la consola.
    # Muy útil para depuración.
    properties:
      hibernate:
        format_sql: true # Formatea el SQL mostrado por 'show-sql' para que sea más legible.
    database-platform: org.hibernate.dialect.PostgreSQLDialect # Especifica el dialecto SQL para PostgreSQL,
    # lo que permite a Hibernate generar SQL optimizado.

  application:
    name: auth-service # ¡NOMBRE MUY IMPORTANTE! Este es el nombre con el que tu microservicio se registrará en Eureka.
    # Otros microservicios (como el API Gateway o el User Service) usarán este nombre para encontrarlo.

  cloud: # Configuración de Spring Cloud para funcionalidades como la mensajería (Stream) y Feign.
    # NOTA CRÍTICA: La sección 'function.definition' se ha ELIMINADO aquí.
    # Se usa StreamBridge para enviar mensajes de forma imperativa,
    # por lo que no necesitamos definir un bean 'Supplier' o 'Function'.
    stream: # Configuración específica para Spring Cloud Stream (mensajería).
      kafka: # Configuración para el binder de Kafka (el adaptador para conectar con Kafka).
        binder: # Detalles de cómo conectar con el broker de Kafka.
          brokers: localhost:9092 # ¡VERIFICAR SI ESTÁS USANDO DOCKER O LOCALHOST DIRECTAMENTE!
            # Si Kafka está en un contenedor Docker en la misma red,
            # deberías usar el nombre del servicio de Docker (ej. 'kafka:29092').
          # Si Kafka está corriendo directamente en tu máquina local, 'localhost:9092' está bien.
      bindings: # Define los canales de entrada (input) y salida (output) para la mensajería.
        userProducer-out-0: # Este es el nombre del canal de salida. Se usa con StreamBridge.send("userProducer-out-0", ...)
          destination: user-created-topic # ¡NOMBRE MUY IMPORTANTE! Este es el nombre del topic (tema) en Kafka
          # al que el 'auth-service' publicará los eventos de usuario creado.
          # El 'user-service' deberá escuchar este mismo topic.
          producer: # Configuración específica para este canal de productor.
            contentType: application/json # Indica que los mensajes se enviarán en formato JSON.

# A continuación, la configuración para Eureka Server.
eureka:
  instance: # Configuración específica de esta instancia de microservicio en Eureka.
    instance-id: ${spring.application.name}:${random.value} # El ID único de esta instancia en Eureka.
    # Usa el nombre de la aplicación y un valor aleatorio para garantizar unicidad.
    prefer-ip-address: true # Le dice a Eureka que, en lugar del hostname, registre la dirección IP de la instancia.
    # Esto puede ser útil en algunos entornos Docker o de red donde la resolución de hostnames puede ser un problema.
  client: # Configuración de cómo este microservicio actuará como cliente de Eureka.
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/ # ¡URL DE EUREKA SERVER!
        # Esta es la URL de tu servidor Eureka.
        # Si tu Eureka Server NO está en Docker y lo ejecutas localmente, 'localhost:8761' está bien.
        # Si tu Eureka Server está en Docker y en la misma red, debería ser algo como
      # 'http://eureka-server:8761/eureka/' (asumiendo que 'eureka-server' es el nombre de su servicio Docker).
      # Por ahora, si lo ejecutas localmente, 'localhost' es correcto.

# ¡IMPORTANTE! Asegúrate de que no tengas configuraciones antiguas de FeignClient directas,
# como una sección 'user-service.url', ya que Spring Cloud Feign se integra con Eureka.